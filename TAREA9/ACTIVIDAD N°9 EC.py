# -*- coding: utf-8 -*-
"""Simulacion_Flocking_MESA2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d2Vd2uchlr6Gyk82kNHJnnDSePUCsT4W
"""

!pip install mesa

import numpy as np
import matplotlib.pyplot as plt
from mesa import Agent, Model
from mesa.time import RandomActivation
from mesa.space import ContinuousSpace
from matplotlib import animation
from IPython.display import HTML

class BoidAgent(Agent):
    def __init__(self, unique_id, model, pos, velocity):
        super().__init__(unique_id, model)
        self.pos = np.array(pos)
        self.velocity = np.array(velocity)

    def step(self):
        neighbors = self.model.space.get_neighbors(self.pos, radius=10, include_center=False)

        if not neighbors:
            new_velocity = self.velocity
        else:
            # Reglas del comportamiento Boids
            align = np.mean([agent.velocity for agent in neighbors], axis=0)
            center_mass = np.mean([agent.pos for agent in neighbors], axis=0)
            cohesion = center_mass - self.pos
            separation = np.sum([self.pos - agent.pos for agent in neighbors if np.linalg.norm(self.pos - agent.pos) < 3], axis=0)

            new_velocity = self.velocity + 0.05 * align + 0.01 * cohesion + 0.1 * separation

        speed = np.linalg.norm(new_velocity)
        if speed > 0:
            new_velocity = (new_velocity / speed) * 1.5

        self.velocity = new_velocity
        self.pos = (self.pos + self.velocity) % [self.model.space.width, self.model.space.height]
        self.model.space.move_agent(self, self.pos)

class FlockingModel(Model):
    def __init__(self, N, width, height):
        self.num_agents = N
        self.space = ContinuousSpace(width, height, torus=True)
        self.schedule = RandomActivation(self)

        for i in range(self.num_agents):
            pos = np.random.rand(2) * [width, height]
            velocity = (np.random.rand(2) - 0.5) * 2
            agent = BoidAgent(i, self, pos, velocity)
            self.space.place_agent(agent, pos)
            self.schedule.add(agent)

    def step(self):
        self.schedule.step()

model = FlockingModel(20, 100, 100)

fig, ax = plt.subplots(figsize=(6, 6))

# Obt√©n posiciones y velocidades iniciales
pos = np.array([agent.pos for agent in model.schedule.agents])
vel = np.array([agent.velocity for agent in model.schedule.agents])

scat = ax.scatter(pos[:, 0], pos[:, 1], c='blue')
quiver = ax.quiver(pos[:, 0], pos[:, 1], vel[:, 0], vel[:, 1],
                   angles='xy', scale_units='xy', scale=1, color='red')

def init():
    ax.set_xlim(0, 100)
    ax.set_ylim(0, 100)
    return scat, quiver

def animate(i):
    model.step()
    pos = np.array([agent.pos for agent in model.schedule.agents])
    vel = np.array([agent.velocity for agent in model.schedule.agents])
    scat.set_offsets(pos)
    quiver.set_offsets(pos)
    quiver.set_UVC(vel[:, 0], vel[:, 1])
    return scat, quiver

ani = animation.FuncAnimation(fig, animate, init_func=init,
                              frames=100, interval=100, blit=True)

from IPython.display import HTML
display = HTML(ani.to_jshtml())

# Para guardar video (opcional)
# ani.save("boids_simulation.mp4", writer='ffmpeg', fps=10)

display